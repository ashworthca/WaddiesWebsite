<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Waddies - Tournament</title>
  <script defer src="/__/firebase/10.8.0/firebase-app-compat.js"></script>
  <script defer src="/__/firebase/10.8.0/firebase-auth-compat.js"></script>
  <script defer src="/__/firebase/10.8.0/firebase-database-compat.js"></script>
  <script defer src="/__/firebase/10.8.0/firebase-app-check-compat.js"></script>
  <script defer src="/__/firebase/init.js?useEmulator=false"></script>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; margin:0; background:#f5f5f7; color:#333; }
    .container { max-width: 1200px; margin: 0 auto; padding: 1rem; }
    .header { display:flex; align-items:center; justify-content:space-between; margin-bottom:1rem; }
    .banner { background:#fff; border-radius:12px; box-shadow:0 1px 3px rgba(0,0,0,0.1); padding:0.75rem 1rem; display:flex; align-items:center; justify-content:space-between; }
    .muted { color:#666; font-size:0.9rem; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 1rem; }
    @media (min-width: 1000px) { .grid { grid-template-columns: 360px 1fr; } }
    .panel { background:#fff; border-radius:12px; box-shadow:0 1px 3px rgba(0,0,0,0.1); padding:1rem; }
    .section-title { font-weight:700; color:#1a1a1a; margin:0 0 0.5rem; }
    label { font-size:0.9rem; color:#555; }
    input, select { padding:8px; border:1px solid #ddd; border-radius:8px; width:100%; }
    .row { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:8px; }
    .btn { background:#0070c9; color:#fff; border:none; padding:8px 12px; border-radius:8px; cursor:pointer; }
    .btn.secondary { background:#455a64; }
    .btn.warn { background:#c62828; }
    .error { background:#fee; color:#c00; padding:8px; border-radius:8px; margin-top:8px; }
    .ok { background:#e7f9ed; color:#0a7d33; padding:6px 10px; border-radius:999px; font-size:0.8rem; }
    .table { width:100%; border-collapse:collapse; font-size:0.95rem; }
    .table th, .table td { padding:8px; border-bottom:1px solid #eee; text-align:left; }
    .pill { padding:2px 8px; border-radius:999px; font-size:0.8rem; }
    .pill.pending { background:#fff6e5; color:#8a5a00; }
    .pill.in_progress { background:#e8f3ff; color:#0b5cab; }
    .pill.completed { background:#e7f9ed; color:#0a7d33; }
    .diag-actions { display:flex; gap:8px; align-items:center; margin-bottom:6px; }
    .diag-log { background:#0b0b0b; color:#d5d5d5; padding:8px; border-radius:8px; max-height:220px; overflow:auto; white-space:pre-wrap; }
  </style>
  <script>
    document.addEventListener('DOMContentLoaded', async () => {
      // App Check (enable with your site key in console when ready)
      try { if (firebase && firebase.appCheck) { firebase.appCheck().activate(undefined, true); } } catch (_) {}

      // Simple diag logger
      function log(message){
        const ts = new Date().toISOString();
        const line = `[${ts}] ${message}`;
        try { console.log(line); } catch(_) {}
        const box = document.getElementById('diagLog');
        if (box){ box.textContent += (box.textContent ? '\n' : '') + line; box.scrollTop = box.scrollHeight; }
      }

      // Auth
      try { await firebase.auth().signInAnonymously(); log('Anonymous auth: success'); } catch (e) { log('Anonymous auth: failed ' + (e?.code||'') + ' ' + (e?.message||'')); }

      const el = (id) => document.getElementById(id);
      const state = { tid: localStorage.getItem('tourneyId') || '', pinOk: false, meta: null, owner: false, teams: {}, schedule: {}, standings: {}, devTournaments: [], players: {} };
      const app = firebase.app(); if (!app.options.databaseURL) { app.options.databaseURL = 'https://waddies-default-rtdb.firebaseio.com'; }
      const db = firebase.database();
      log('App init; dbURL=' + (app.options.databaseURL||''));

      function setBanner(){
        const name = state.meta?.name || 'Tournament';
        const ownerBadge = state.owner ? '<span class="ok">Owner</span>' : '';
        el('bannerTitle').innerHTML = `${name} ${ownerBadge}`;
      }

      async function hashSHA256Hex(str){
        const enc = new TextEncoder();
        const buf = await crypto.subtle.digest('SHA-256', enc.encode(str));
        return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
      }

      async function resolveTournamentId(input){
        const raw = (input||'').trim();
        if (!raw) throw new Error('Enter a join code or tournament ID');
        // Normalize code: remove non-alphanum and uppercase
        const norm = raw.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
        // Heuristic: treat short-ish token as a code; else assume ID
        const looksLikeCode = /^[A-Z0-9]{4,12}$/.test(norm);
        log(`resolve: input='${raw}', norm='${norm}', looksLikeCode=${looksLikeCode}`);
        if (!looksLikeCode) { log('resolve: treating input as tournament ID'); return raw; }

        // FAST PATH: query tournaments by meta.joinCode first (matches app schema)
        try {
          log("resolve: FAST query /tournaments by meta/joinCode == '" + norm + "'");
          const qFast = await db.ref('/tournaments').orderByChild('meta/joinCode').equalTo(norm).once('value');
          if (qFast.exists()){
            const obj = qFast.val() || {};
            const tid = Object.keys(obj)[0] || '';
            log('resolve: FAST found tid=' + tid);
            if (tid) return tid;
          }
          if (raw !== norm) {
            log("resolve: FAST query /tournaments by meta/joinCode == '" + raw + "'");
            const qFastRaw = await db.ref('/tournaments').orderByChild('meta/joinCode').equalTo(raw).once('value');
            if (qFastRaw.exists()){
              const obj = qFastRaw.val() || {};
              const tid = Object.keys(obj)[0] || '';
              log('resolve: FAST found (raw) tid=' + tid);
              if (tid) return tid;
            }
          }
        } catch (e) { log('resolve: FAST meta/joinCode query error ' + (e?.code||'') + ' ' + (e?.message||'')); }

        // Try multiple common mapping locations used by the app/backend
        const bases = ['/tournament-codes', '/tournaments-by-code', '/tournamentCodes', '/codes/tournaments'];
        const keys = [norm, raw]; // try normalized and raw key
        const candidates = [];
        bases.forEach(b => keys.forEach(k => candidates.push(`${b}/${k}`)));

        for (const path of candidates){
          try {
            log('resolve: checking ' + path);
            const snap = await db.ref(path).once('value');
            const exists = snap.exists();
            log('resolve: ' + path + ' exists=' + exists);
            if (exists){
              const val = snap.val();
              const tid = (val && (val.tournamentId || val.tournamentID || val.id || val.tid)) || '';
              log('resolve: mapping found tid=' + (tid || '(empty)'));
              if (tid) return tid;
            }
          } catch(_) { /* ignore and continue */ }
        }

        // Query tournaments by meta.joinCode (preferred per app schema)
        try {
          log("resolve: query /tournaments by meta/joinCode == '" + norm + "'");
          const q1 = await db.ref('/tournaments').orderByChild('meta/joinCode').equalTo(norm).once('value');
          if (q1.exists()){
            const obj = q1.val() || {};
            const tid = Object.keys(obj)[0] || '';
            log('resolve: found by meta/joinCode tid=' + tid);
            if (tid) return tid;
          }
          if (raw !== norm) {
            log("resolve: query /tournaments by meta/joinCode == '" + raw + "'");
            const q1b = await db.ref('/tournaments').orderByChild('meta/joinCode').equalTo(raw).once('value');
            if (q1b.exists()){
              const obj = q1b.val() || {};
              const tid = Object.keys(obj)[0] || '';
              log('resolve: found by meta/joinCode (raw) tid=' + tid);
              if (tid) return tid;
            }
          }
        } catch (e) { log('resolve: meta/joinCode query error ' + (e?.code||'') + ' ' + (e?.message||'')); }

        // Fallback: some schemas place joinCode at root of tournament
        try {
          log("resolve: query /tournaments by joinCode == '" + norm + "'");
          const q2 = await db.ref('/tournaments').orderByChild('joinCode').equalTo(norm).once('value');
          if (q2.exists()){
            const obj = q2.val() || {};
            const tid = Object.keys(obj)[0] || '';
            log('resolve: found by joinCode tid=' + tid);
            if (tid) return tid;
          }
          if (raw !== norm) {
            log("resolve: query /tournaments by joinCode == '" + raw + "'");
            const q2b = await db.ref('/tournaments').orderByChild('joinCode').equalTo(raw).once('value');
            if (q2b.exists()){
              const obj = q2b.val() || {};
              const tid = Object.keys(obj)[0] || '';
              log('resolve: found by joinCode (raw) tid=' + tid);
              if (tid) return tid;
            }
          }
        } catch (e) { log('resolve: joinCode query error ' + (e?.code||'') + ' ' + (e?.message||'')); }

        // As a last resort, attempt raw (user may have typed the ID itself)
        log('resolve: mapping not found; falling back to raw id');
        return raw;
      }

      function toggleViews(){
        const joined = !!(state.tid && state.pinOk);
        el('joinPanel').style.display = joined ? 'none' : 'block';
        el('mainPanel').style.display = joined ? 'block' : 'none';
        const ownerOnly = state.owner && joined;
        el('teamsIntake').style.display = ownerOnly ? 'block' : 'none';
        el('ownerAuth').style.display = joined ? 'block' : 'none';
        el('ownerSignedOut').style.display = state.owner ? 'none' : 'inline';
        el('ownerSignedIn').style.display = state.owner ? 'inline' : 'none';
      }

      async function checkOwner(){
        const user = firebase.auth().currentUser; const uid = user?.uid || null;
        state.owner = !!(uid && state.meta && state.meta.ownerUid && uid === state.meta.ownerUid);
        setBanner(); toggleViews();
      }

      function observeTournament(){
        if (!state.tid) return;
        db.ref(`/tournaments/${state.tid}/meta`).on('value', s=>{ state.meta = s.val() || null; setBanner(); checkOwner(); });
        db.ref(`/tournaments/${state.tid}/teams`).on('value', s=>{
          const val = s.val() || {};
          state.teams = val;
          // Build id->team lookup that works for both object and array shapes
          const map = {};
          if (Array.isArray(val)){
            val.filter(Boolean).forEach(t => {
              const id = (t && (t.id || t.teamId || t.guid || t.GUID || t.teamGUID)) || null;
              if (id) map[id] = t;
            });
          } else if (val && typeof val === 'object'){
            Object.entries(val).forEach(([k, t]) => {
              const id = (t && (t.id || t.teamId || t.guid || t.GUID || t.teamGUID)) || k;
              map[id] = t;
            });
          }
          state.teamById = map;
          renderTeams(); renderSchedule(); renderStandings();
        });
        db.ref(`/tournaments/${state.tid}/schedule`).on('value', s=>{ state.schedule = s.val() || {}; renderSchedule(); });
        db.ref(`/tournaments/${state.tid}/standings`).on('value', s=>{ state.standings = s.val() || {}; renderStandings(); });
        // Observe global players for name/email resolution (read-only)
        try {
          db.ref(`/players`).on('value', s=>{
            const data = s.val() || {};
            state.players = data;
            // Build reverse maps: by exact key, by player.id, by previousIDs, and case-normalized variants
            const byId = {};
            const byAlt = {};
            Object.entries(data).forEach(([key, p]) => {
              if (!p || typeof p !== 'object') return;
              byId[key] = p;
              // Case-normalized keys
              byAlt[key.toLowerCase()] = p;
              byAlt[key.toUpperCase()] = p;
              const altId = p.id || '';
              if (altId) {
                byAlt[altId] = p;
                byAlt[(altId+'').toLowerCase()] = p;
                byAlt[(altId+'').toUpperCase()] = p;
              }
              const prev = p.previousIDs && typeof p.previousIDs === 'object' ? Object.keys(p.previousIDs) : [];
              prev.forEach(oldId => {
                byAlt[oldId] = p;
                byAlt[(oldId+'').toLowerCase()] = p;
                byAlt[(oldId+'').toUpperCase()] = p;
              });
            });
            state.playerById = byId;
            state.playerByAltId = byAlt;
            renderTeams(); renderStandings();
          });
        } catch(_) {}
      }

      // DEV: observe all tournaments to list and quick-select (temporary)
      function observeAllTournamentsDev(){
        try {
          log('dev: observing /tournaments');
          db.ref('/tournaments').on('value', s => {
            const root = s.val() || {};
            const rows = Object.entries(root).map(([tid, node]) => {
              const meta = (node && node.meta) ? node.meta : node;
              const name = (meta && meta.name) || '(unnamed)';
              const code = (meta && meta.joinCode) || '';
              return { tid, name, code };
            });
            state.devTournaments = rows;
            renderDevTournaments();
          });
        } catch (e){ log('dev: observe error ' + (e?.message||e)); }
      }

      function renderDevTournaments(){
        const container = el('devList'); if (!container) return;
        const q = (el('devFilter').value || '').toLowerCase();
        const items = (state.devTournaments || []).filter(x => {
          return !q || x.tid.toLowerCase().includes(q) || x.name.toLowerCase().includes(q) || x.code.toLowerCase().includes(q);
        }).sort((a,b)=> a.name.localeCompare(b.name));
        container.innerHTML = '';
        items.forEach(x => {
          const row = document.createElement('div');
          row.style.display = 'grid'; row.style.gridTemplateColumns = '1fr auto'; row.style.gap = '8px'; row.style.alignItems = 'center';
          const left = document.createElement('div');
          left.innerHTML = `<strong>${x.name}</strong> <span class="muted">${x.tid.slice(0,8)}…</span>${x.code? ` · <span class='muted'>${x.code}</span>`:''}`;
          const btn = document.createElement('button'); btn.className = 'btn secondary'; btn.textContent = 'Use';
          btn.onclick = () => { el('joinCode').value = x.tid; log('dev: selected tid=' + x.tid); window.scrollTo({ top: 0, behavior: 'smooth' }); };
          row.appendChild(left); row.appendChild(btn);
          container.appendChild(row);
        });
      }

      function renderTeams(){
        const list = el('teamsList'); list.innerHTML = '';
        const entries = [];
        const src = state.teams || {};
        if (Array.isArray(src)){
          src.filter(Boolean).forEach(t => {
            const displayName = (typeof t?.teamName === 'string' && t.teamName) || (t?.name || '');
            let players = [];
            if (Array.isArray(t?.players)){
              if (t.players.length && typeof t.players[0] === 'string') players = t.players;
              else players = t.players.map(p => (p && typeof p === 'object' && p.name) ? p.name : '').filter(Boolean);
            } else if (Array.isArray(t?.playerNames)) {
              players = t.playerNames.filter(Boolean);
            }
            entries.push({ id: t?.id || t?.teamId || t?.guid || t?.GUID || '', name: displayName, players });
          });
        } else if (src && typeof src === 'object'){
          Object.entries(src).forEach(([id, t]) => {
            if (typeof t === 'string') { entries.push({ id, name: t, players: [] }); return; }
            const displayName = (typeof t?.teamName === 'string' && t.teamName) || (t?.name || '');
            let players = [];
            if (Array.isArray(t?.players)){
              if (t.players.length && typeof t.players[0] === 'string') players = t.players;
              else players = t.players.map(p => (p && typeof p === 'object' && p.name) ? p.name : '').filter(Boolean);
            } else if (Array.isArray(t?.playerNames)) {
              players = t.playerNames.filter(Boolean);
            }
            entries.push({ id, name: displayName, players });
          });
        }
        entries.sort((a,b)=> a.name.localeCompare(b.name));
        entries.forEach(t=>{
          const row = document.createElement('div');
          const players = (t.players||[]).filter(Boolean).join(', ');
          row.textContent = t.name + (players? ` — ${players}`:'');
          list.appendChild(row);
        });
      }

      function teamNameById(id){
        if (!id) return '';
        const t = (state.teamById && state.teamById[id]) || (state.teams && state.teams[id]) || null;
        if (t == null) return id.slice(0,6) + '…';
        if (typeof t === 'string') return t;
        if (typeof t === 'object') return (typeof t.teamName === 'string' && t.teamName) || (typeof t.name === 'string' && t.name) || id.slice(0,6) + '…';
        return id.slice(0,6) + '…';
      }

      function playerLabel(pid){
        if (!pid) return '';
        const p = (state.playerById && state.playerById[pid]) || (state.playerByAltId && state.playerByAltId[pid]) || (state.playerByAltId && state.playerByAltId[(pid+'').toLowerCase()]) || (state.playerByAltId && state.playerByAltId[(pid+'').toUpperCase()]);
        if (!p || typeof p !== 'object') return pid.slice(0,6) + '…';
        const name = p.name || pid.slice(0,6) + '…';
        const email = (p.emailPrivacy === true) ? '' : (p.email || '');
        return email ? `${name} (${email})` : name;
      }

      function listPlayerLabelsFromStandingsEntry(s){
        if (!s) return [];
        const playersNode = s.players || s.playerIds || s.roster || null;
        let ids = [];
        if (Array.isArray(playersNode)){
          if (playersNode.length && typeof playersNode[0] === 'string') ids = playersNode;
          else ids = playersNode.map(x => (x && (x.id || x.playerId || x.pid)) || '').filter(Boolean);
        } else if (playersNode && typeof playersNode === 'object'){
          ids = Object.keys(playersNode);
        }
        return ids.map(playerLabel);
      }

      function renderSchedule(){
        const tbody = el('scheduleBody'); tbody.innerHTML = '';
        const items = Object.values(state.schedule||{});
        items.sort((a,b)=> (a?.startTime||0) - (b?.startTime||0));
        items.forEach(it => {
          const tr = document.createElement('tr');
          const start = it?.startTime ? new Date(it.startTime*1000).toLocaleString() : '';
          const status = String(it?.status||'pending');
          const pillClass = status.replace('-', '_');
          const score = (status==='completed' && it?.finalScore) ? ` — ${it.finalScore}` : '';
          tr.innerHTML = `<td>${it?.round ?? ''}</td><td>${it?.court ?? ''}</td><td>${start}</td><td>${teamNameById(it?.team1Id)} vs ${teamNameById(it?.team2Id)}${score}</td><td><span class="pill ${pillClass}">${status}</span></td>`;
          tbody.appendChild(tr);
        });
      }

      function renderStandings(){
        const tbody = el('standingsBody'); tbody.innerHTML = '';
        const src = state.standings || {};
        let rows = [];
        if (Array.isArray(src)){
          rows = src.filter(Boolean).map(s => {
            const teamId = s.teamId || s.teamID || s.team || s.id || '';
            const teamName = s.teamName || s.name || '';
            const playerLabels = listPlayerLabelsFromStandingsEntry(s);
            return { teamId, teamName, wins: Number(s?.wins||0), losses: Number(s?.losses||0), points: Number(s?.points||0), players: playerLabels };
          });
        } else if (src && typeof src === 'object'){
          rows = Object.entries(src).map(([key, s]) => {
            const teamId = s?.teamId || s?.teamID || s?.team || key;
            const teamName = s?.teamName || s?.name || '';
            const playerLabels = listPlayerLabelsFromStandingsEntry(s);
            return { teamId, teamName, wins: Number(s?.wins||0), losses: Number(s?.losses||0), points: Number(s?.points||0), players: playerLabels };
          });
        }
        rows.sort((a,b)=> (b.points - a.points) || (b.wins - a.wins) || (a.losses - b.losses));
        rows.forEach(r => {
          const tr = document.createElement('tr');
          const label = r.teamName || teamNameById(r.teamId);
          const playersText = (r.players && r.players.length) ? r.players.join(', ') : '';
          tr.innerHTML = `<td>${label}</td><td>${r.wins}-${r.losses}</td><td>${r.points}</td><td>${playersText}</td>`;
          tbody.appendChild(tr);
        });
      }

      async function doJoin(){
        const errBox = el('joinErr');
        errBox.textContent = '';
        const codeOrId = el('joinCode').value.trim();
        const pin = el('joinPin').value.trim();
        if (!/^[0-9]{4}$/.test(pin)) { errBox.textContent = 'PIN must be 4 digits'; return; }
        el('joinBtn').disabled = true; el('joinBtn').textContent = 'Joining…';
        try {
          const tid = await resolveTournamentId(codeOrId);
          // Fetch meta with fallbacks: /tournaments/{tid}/meta then /tournaments/{tid}
          let metaPath = `/tournaments/${tid}/meta`;
          log('join: fetching meta at ' + metaPath);
          let metaSnap = await db.ref(metaPath).once('value');
          if (!metaSnap.exists()){
            metaPath = `/tournaments/${tid}`;
            log('join: fallback fetch at ' + metaPath);
            metaSnap = await db.ref(metaPath).once('value');
          }
          log('join: meta exists=' + metaSnap.exists());
          if (!metaSnap.exists()) throw new Error('Tournament not found (try entering the Tournament ID)');
          const rawMeta = metaSnap.val();
          const meta = rawMeta && (rawMeta.meta ? rawMeta.meta : rawMeta);
          const salt = (meta?.scoringPasswordSalt || rawMeta?.meta?.scoringPasswordSalt || '');
          const want = (meta?.scoringPasswordHash || rawMeta?.meta?.scoringPasswordHash || '').toLowerCase();
          const have = (await hashSHA256Hex(`${salt}${pin}`)).toLowerCase();
          const match = !!(want && have === want);
          log('join: pin validation match=' + match + ' (not logging pin/hash)');
          if (!match) { errBox.textContent = 'Invalid PIN or code/ID'; return; }
          state.tid = tid; state.pinOk = true; state.meta = meta; localStorage.setItem('tourneyId', tid);
          setBanner(); toggleViews(); observeTournament();
        } catch (e){
          const msg = (e && e.code === 'PERMISSION_DENIED') ? 'Permission denied (check rules)' : (e?.message || String(e));
          errBox.textContent = msg;
          log('join: error ' + msg);
        } finally {
          el('joinBtn').disabled = false; el('joinBtn').textContent = 'Join';
        }
      }

      async function addTeam(){
        if (!state.owner || !state.tid) return;
        const name = el('teamName').value.trim();
        const p1 = el('player1').value.trim();
        const p2 = el('player2').value.trim();
        if (!name) { alert('Enter a team name'); return; }
        const teamId = db.ref(`/tournaments/${state.tid}/teams`).push().key;
        // Write as teamName and players (array of strings) for compatibility
        const players = [];
        if (p1) players.push(p1);
        if (p2) players.push(p2);
        try {
          log('addTeam: writing teamId=' + teamId + ' name=' + name);
          await db.ref(`/tournaments/${state.tid}/teams/${teamId}`).set({ teamName: name, name, players });
          el('teamName').value=''; el('player1').value=''; el('player2').value='';
          log('addTeam: success');
        } catch (e){
          const msg = (e && e.code === 'PERMISSION_DENIED') ? 'Add team failed: owner account required' : ('Add team failed: ' + (e?.message||e));
          alert(msg);
          log('addTeam: error ' + msg);
        }
      }

      // Wire UI
      el('joinBtn').onclick = doJoin;
      el('addTeamBtn').onclick = addTeam;
      firebase.auth().onAuthStateChanged((u)=>{ log('auth: state changed uid=' + (u?.uid||'null')); checkOwner(); });
      el('ownerLoginBtn').onclick = async ()=>{
        const email = el('ownerEmail').value.trim();
        const pass = el('ownerPass').value;
        el('ownerErr').textContent = '';
        try { await firebase.auth().signInWithEmailAndPassword(email, pass); log('owner: sign-in attempt for ' + email); }
        catch(e){ const m = e?.message || String(e); el('ownerErr').textContent = m; log('owner: sign-in error ' + m); }
      };
      el('ownerLogoutBtn').onclick = async ()=>{ try { await firebase.auth().signOut(); log('owner: sign-out'); } catch(e){ log('owner: sign-out error ' + (e?.message||e)); } };

      // Owner sign-in with Google (popup)
      const googleBtn = document.getElementById('ownerGoogleBtn');
      if (googleBtn) googleBtn.onclick = async ()=>{
        el('ownerErr').textContent = '';
        try { await firebase.auth().signInWithPopup(new firebase.auth.GoogleAuthProvider()); log('owner: Google sign-in popup complete'); }
        catch(e){ const m = e?.message || String(e); el('ownerErr').textContent = m; log('owner: Google sign-in error ' + m); }
      };

      // Passwordless Email Link sign-in
      const linkBtn = document.getElementById('ownerLinkBtn');
      const actionCodeSettings = {
        url: window.location.origin + '/tourney.html',
        handleCodeInApp: true
      };
      if (linkBtn) linkBtn.onclick = async ()=>{
        const email = el('ownerEmail').value.trim(); el('ownerErr').textContent = '';
        if (!email) { el('ownerErr').textContent = 'Enter your owner email to send link'; return; }
        try {
          await firebase.auth().sendSignInLinkToEmail(email, actionCodeSettings);
          try { window.localStorage.setItem('emailForSignIn', email); } catch(_){ }
          log('owner: email link sent to ' + email);
        } catch(e){ const m = e?.message || String(e); el('ownerErr').textContent = m; log('owner: email link error ' + m); }
      };

      // Complete email link sign-in if present
      try {
        if (firebase.auth().isSignInWithEmailLink(window.location.href)){
          let email = '';
          try { email = window.localStorage.getItem('emailForSignIn') || ''; } catch(_){ }
          if (!email) email = window.prompt('Confirm your email for sign-in');
          if (email) {
            try { await firebase.auth().signInWithEmailLink(email, window.location.href); log('owner: email link sign-in complete'); }
            catch(e){ log('owner: email link completion error ' + (e?.message||e)); }
        }
        }
      } catch(_){}

      // Auto-join if we have tid (PIN still required)
      if (state.tid) { el('joinCode').value = state.tid; log('auto-fill from localStorage.tourneyId=' + state.tid); }

      // Diag copy/clear
      document.getElementById('diagCopy').onclick = async ()=>{
        try { await navigator.clipboard.writeText(document.getElementById('diagLog').textContent || ''); } catch(_){}
      };
      document.getElementById('diagClear').onclick = ()=>{ const b=document.getElementById('diagLog'); if(b){ b.textContent=''; } };

      // Wire dev list
      const devFilter = document.getElementById('devFilter'); if (devFilter) devFilter.oninput = renderDevTournaments;
      observeAllTournamentsDev();
    });
  </script>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Waddies Championship</h1>
      <div class="muted"><a href="index.html">Home</a></div>
    </div>

    <div class="banner"><div id="bannerTitle">Tournament</div></div>

    <div class="panel" style="margin-top:1rem;">
      <div class="section-title">All Tournaments (dev)</div>
      <div class="muted">Temporary list for troubleshooting. Click Use to prefill the join ID; PIN still required.</div>
      <div class="row" style="margin-top:8px;">
        <div>
          <label for="devFilter">Filter</label>
          <input id="devFilter" placeholder="Search by name, ID, or code" />
        </div>
        <div></div>
      </div>
      <div id="devList" style="display:grid; gap:6px; margin-top:8px;"></div>
    </div>

    <div id="ownerAuth" class="panel" style="display:none; margin-top:1rem;">
      <div class="section-title">Owner Sign In</div>
      <div class="muted">Sign in with the same account that created the tournament to add teams.</div>
      <div id="ownerSignedOut" style="display:none; margin-top:8px;">
        <div class="row">
          <div>
            <label for="ownerEmail">Email</label>
            <input id="ownerEmail" autocomplete="username" />
          </div>
          <div>
            <label for="ownerPass">Password</label>
            <input id="ownerPass" type="password" autocomplete="current-password" />
          </div>
        </div>
        <div style="margin-top:8px; display:flex; gap:8px; align-items:center; flex-wrap: wrap;">
          <button id="ownerLoginBtn" class="btn secondary">Sign In</button>
          <button id="ownerLinkBtn" class="btn secondary">Send Sign-in Link</button>
          <button id="ownerGoogleBtn" class="btn secondary">Sign in with Google</button>
          <div id="ownerErr" class="error" style="display:inline-block;"></div>
        </div>
      </div>
      <div id="ownerSignedIn" style="display:none; margin-top:8px;">
        <span class="ok">Signed in as owner</span>
        <button id="ownerLogoutBtn" class="btn warn" style="margin-left:8px;">Sign Out</button>
      </div>
    </div>

    <div id="joinPanel" class="panel" style="margin-top:1rem;">
      <div class="section-title">Join Tournament</div>
      <div class="row">
        <div>
          <label for="joinCode">Join Code or Tournament ID</label>
          <input id="joinCode" placeholder="ABC123 or tid_..." />
        </div>
        <div>
          <label for="joinPin">4-digit PIN</label>
          <input id="joinPin" placeholder="1234" inputmode="numeric" maxlength="4" />
        </div>
      </div>
      <div style="margin-top:8px; display:flex; gap:8px; align-items:center;">
        <button id="joinBtn" class="btn">Join</button>
        <div id="joinErr" class="error" style="display:inline-block;"></div>
      </div>
    </div>

    <div id="mainPanel" style="display:none;" class="grid">
      <div>
        <div id="teamsIntake" class="panel" style="display:none;">
          <div class="section-title">Add Team (Owner Only)</div>
          <div style="display:grid; gap:8px;">
            <div>
              <label for="teamName">Team Name</label>
              <input id="teamName" placeholder="Team name" />
            </div>
            <div class="row">
              <div>
                <label for="player1">Player 1</label>
                <input id="player1" placeholder="Player name" />
              </div>
              <div>
                <label for="player2">Player 2 (optional)</label>
                <input id="player2" placeholder="Player name" />
              </div>
            </div>
            <div><button id="addTeamBtn" class="btn">Add Team</button></div>
          </div>
        </div>

        <div class="panel">
          <div class="section-title">Teams</div>
          <div id="teamsList" style="display:grid; gap:6px;"></div>
        </div>
      </div>

      <div>
        <div class="panel">
          <div class="section-title">Schedule</div>
          <table class="table">
            <thead><tr><th>Round</th><th>Court</th><th>Start</th><th>Match</th><th>Status</th></tr></thead>
            <tbody id="scheduleBody"></tbody>
          </table>
        </div>

        <div class="panel">
          <div class="section-title">Standings</div>
          <table class="table">
            <thead><tr><th>Team</th><th>W-L</th><th>Points</th><th>Players</th></tr></thead>
            <tbody id="standingsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:1rem;">
      <div class="section-title">Diagnostics (temporary)</div>
      <div class="diag-actions">
        <button id="diagCopy" class="btn secondary">Copy</button>
        <button id="diagClear" class="btn warn">Clear</button>
        <span class="muted">Include this log when reporting issues.</span>
      </div>
      <div id="diagLog" class="diag-log mono"></div>
    </div>
  </div>
</body>
</html>


