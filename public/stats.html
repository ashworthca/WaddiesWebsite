<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Waddies - Player Statistics</title>
    <!-- Firebase SDK -->
    <script defer src="/__/firebase/10.8.0/firebase-app-compat.js"></script>
    <script defer src="/__/firebase/10.8.0/firebase-database-compat.js"></script>
    <script defer src="/__/firebase/init.js?useEmulator=false"></script>
    <!-- Chart.js for statistics visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #f5f5f7;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }
        .header {
            text-align: center;
            margin-bottom: 2rem;
        }
        .filters {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .filter-group {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        .filter-group label {
            min-width: 100px;
        }
        .filter-group select, .filter-group input {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .stats-table th, .stats-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        .stats-table th {
            background: #f8f9fa;
            font-weight: 600;
            cursor: pointer;
        }
        .stats-table th:hover {
            background: #e9ecef;
        }
        .stats-table tr:last-child td {
            border-bottom: none;
        }
        .stats-table tbody tr:hover {
            background: #f8f9fa;
        }
        .player-name {
            color: #0070c9;
            text-decoration: none;
            font-weight: 500;
        }
        .player-name:hover {
            text-decoration: underline;
        }
        .loading {
            text-align: center;
            padding: 2rem;
            font-size: 1.2rem;
            color: #666;
        }
        .error {
            background: #fee;
            color: #c00;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #ddd;
        }
        .footer a {
            color: #0070c9;
            text-decoration: none;
            margin: 0 1rem;
        }
        .footer a:hover {
            text-decoration: underline;
        }
        /* Modal styles for player details */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            position: relative;
            background: white;
            margin: 2rem auto;
            padding: 2rem;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .close-modal {
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 600;
            color: #0070c9;
        }
        .stat-label {
            color: #666;
            font-size: 0.9rem;
        }
        .chart-container {
            margin: 2rem 0;
            height: 300px;
        }
        .matches-list {
            margin-top: 2rem;
        }
        .match-item {
            padding: 1rem;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-bottom: 1rem;
            cursor: pointer;
        }
        .match-item:hover {
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Player Statistics</h1>
        </div>

        <div class="filters">
            <div class="filter-group">
                <label for="dateRange">Date Range:</label>
                <select id="dateRange">
                    <option value="all">All Time</option>
                    <option value="month">Last Month</option>
                    <option value="3months">Last 3 Months</option>
                    <option value="year">Last Year</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="gameType">Game Type:</label>
                <select id="gameType">
                    <option value="all">All Games</option>
                    <option value="1v1">1v1</option>
                    <option value="2v2">2v2</option>
                </select>
            </div>
            <div class="filter-group">
                <label for="levelFilter">Level:</label>
                <select id="levelFilter">
                    <option value="all">All Levels</option>
                    <option value="pro">Pro Only</option>
                </select>
            </div>
        </div>

        <div id="loadingIndicator" class="loading" style="display: none;">
            Loading statistics...
        </div>

        <table class="stats-table">
            <thead>
                <tr>
                    <th data-sort="name">Player Name ↕</th>
                    <th data-sort="wins">Wins ↕</th>
                    <th data-sort="losses">Losses ↕</th>
                    <th data-sort="totalGames">Total Games ↕</th>
                    <th data-sort="pointsScored">Points Scored ↕</th>
                    <th data-sort="avgPointsPerRound">Avg Pts/Round ↕</th>
                    <th data-sort="waddiesHoled">Waddies Holed ↕</th>
                    <th data-sort="scoringRounds">Scoring Rounds ↕</th>
                    <th data-sort="bestRound">Best Round ↕</th>
                    <th data-sort="hammerPercent">With Hammer % ↕</th>
                    <th data-sort="shootingFirstPercent">Shooting First % ↕</th>
                    <th data-sort="carryPercent">Carry % ↕</th>
                </tr>
            </thead>
            <tbody id="statsTableBody">
                <!-- Data will be populated here -->
            </tbody>
        </table>

        <!-- Player Details Modal -->
        <div id="playerModal" class="modal">
            <div class="modal-content">
                <span class="close-modal">&times;</span>
                <h2 id="modalPlayerName"></h2>
                <div class="stats-grid" id="modalStats">
                    <!-- Player stats will be populated here -->
                </div>
                <div class="chart-container">
                    <canvas id="playerChart"></canvas>
                </div>
                <div class="matches-list" id="playerMatches">
                    <!-- Match history will be populated here -->
                </div>
            </div>
        </div>

        <div class="footer">
            <a href="index.html">Home</a>
            <a href="marketing.html">About</a>
            <a href="privacypolicy.html">Privacy Policy</a>
            <a href="termsandconditions.html">Terms & Conditions</a>
        </div>
    </div>

    <script>
        // Initialize Firebase and load data
        // Make data objects global so helper functions can access them
        window.playersData = {};
        window.gamesData = {};
        window.playerRoundsData = {};

        document.addEventListener('DOMContentLoaded', function() {
            let currentSort = { column: 'wins', direction: 'desc' };
            const modal = document.getElementById('playerModal');
            const closeModal = document.querySelector('.close-modal');
            // use a distinct global name to avoid clashing with DOM id
            window.playerChartInstance = null;

            // Close modal when clicking the close button or outside the modal
            closeModal.onclick = () => modal.style.display = 'none';
            window.onclick = (e) => {
                if (e.target === modal) modal.style.display = 'none';
            };

            // Initialize Firebase and load data
            function loadPlayerStats() {
                document.getElementById('loadingIndicator').style.display = 'block';
                try {
                    if (!firebase || !firebase.app) {
                        throw new Error('Firebase SDK not loaded. Check that the Firebase scripts are loading correctly.');
                    }
                    console.log('Getting Firebase app...');
                    const app = firebase.app();
                    console.log('Firebase app config:', app.options);
                    
                    if (!app.options.databaseURL) {
                        console.warn('No databaseURL in Firebase config, setting manually...');
                        app.options.databaseURL = 'https://waddies-default-rtdb.firebaseio.com';
                    }
                    
                    console.log('Getting database reference...');
                    const db = firebase.database();
                    
                    console.log('Loading data from RTDB...');
                    db.ref('/players').once('value')
                        .then(async (playersSnapshot) => {
                            window.playersData = playersSnapshot.val() || {};
                            console.log('Players:', Object.keys(window.playersData).length);

                            // Load player-rounds per player (requires rules to allow read)
                            const playerIds = Object.keys(window.playersData);
                            const roundsByPlayer = {};
                            const gameIdSet = new Set();

                            for (const pid of playerIds) {
                                try {
                                    const snap = await db.ref(`/player-rounds/${pid}`).once('value');
                                    const val = snap.val() || {};
                                    roundsByPlayer[pid] = val;
                                    Object.keys(val).forEach(gid => gameIdSet.add(gid));
                                } catch (e) {
                                    console.warn('player-rounds read blocked for', pid, e?.code || e?.message);
                                }
                            }

                            window.playerRoundsData = roundsByPlayer;
                            console.log('Player Rounds players loaded:', Object.keys(window.playerRoundsData).length);

                            // Load games individually by id (rules allow /games/$gameId even if /games root is blocked)
                            const gameIds = Array.from(gameIdSet);
                            const gamesData = {};
                            await Promise.all(gameIds.map(async (gid) => {
                                try {
                                    const gsnap = await db.ref(`/games/${gid}`).once('value');
                                    if (gsnap.exists()) gamesData[gid] = gsnap.val();
                                } catch (e) {
                                    console.warn('game read blocked for', gid, e?.code || e?.message);
                                }
                            }));

                            window.gamesData = gamesData;
                            console.log('Games loaded individually:', Object.keys(window.gamesData).length);

                            document.getElementById('loadingIndicator').style.display = 'none';
                            updateTable();
                        })
                        .catch((error) => {
                            console.error('Error loading data:', error);
                            let errorMessage = 'Error loading statistics: ' + error.message;
                            if (error.code) {
                                errorMessage += ' (Code: ' + error.code + ')';
                            }
                            document.getElementById('loadingIndicator').style.display = 'none';
                            document.querySelector('.stats-table').insertAdjacentHTML('beforebegin', 
                                `<div class="error">${errorMessage}</div>`);
                        });
                } catch (error) {
                    console.error('Error initializing Firebase:', error);
                    document.getElementById('loadingIndicator').style.display = 'none';
                    document.querySelector('.stats-table').insertAdjacentHTML('beforebegin', 
                        `<div class="error">Error initializing Firebase: ${error.message}</div>`);
                }
            }

            // Update table with current filters and sorting
            function updateTable() {
                const tbody = document.getElementById('statsTableBody');
                const dateRange = document.getElementById('dateRange').value;
                const gameType = document.getElementById('gameType').value;
                const levelFilter = document.getElementById('levelFilter').value;

                // Convert players data to array for sorting
                let players = Object.entries(window.playersData || {}).map(([id, data]) => ({
                    id,
                    name: data.name,
                    wins: calculateWins(id, dateRange, gameType, levelFilter),
                    losses: calculateLosses(id, dateRange, gameType, levelFilter),
                    totalGames: calculateTotalGames(id, dateRange, gameType, levelFilter),
                    avgPointsPerRound: calculateAveragePointsPerRound(id),
                    waddiesHoled: calculateWaddiesHoled(id),
                    scoringRounds: calculateScoringRounds(id),
                    bestRound: calculateBestRound(id),
                    hammerPercent: calculateHammerPercentage(id),
                    shootingFirstPercent: calculateShootingFirstPercentage(id),
                    carryPercent: calculateCarryPercentage(id)
                }));

                // Sort players
                players.sort((a, b) => {
                    const direction = currentSort.direction === 'asc' ? 1 : -1;
                    return (a[currentSort.column] - b[currentSort.column]) * direction;
                });

                // Generate table HTML
                tbody.innerHTML = players.map(player => `
                    <tr>
                        <td><a href="#" class="player-name" data-player-id="${player.id}">${player.name}</a></td>
                        <td>${calculateWins(player.id, dateRange, gameType)}</td>
                        <td>${calculateLosses(player.id, dateRange, gameType)}</td>
                        <td>${calculateTotalGames(player.id, dateRange, gameType)}</td>
                        <td>${calculatePointsScored(player.id, dateRange, gameType)}</td>
                        <td>${calculateAveragePointsPerRound(player.id).toFixed(1)}</td>
                        <td>${calculateWaddiesHoled(player.id)}</td>
                        <td>${calculateScoringRounds(player.id)}</td>
                        <td>${calculateBestRound(player.id)}</td>
                        <td>${calculateHammerPercentage(player.id).toFixed(1)}%</td>
                        <td>${calculateShootingFirstPercentage(player.id).toFixed(1)}%</td>
                        <td>${calculateCarryPercentage(player.id).toFixed(1)}%</td>
                    </tr>
                `).join('');

                // Add click handlers for player names
                document.querySelectorAll('.player-name').forEach(link => {
                    link.onclick = (e) => {
                        e.preventDefault();
                        showPlayerDetails(link.dataset.playerId);
                    };
                });
            }

            // Show detailed player statistics in modal
            function showPlayerDetails(playerId) {
                const player = (window.playersData && window.playersData[playerId]) || null;
                if (!player) return;

                document.getElementById('modalPlayerName').textContent = player.name;
                // Recompute fresh from current globals to avoid stale zeros
                const wins = calculateWins(playerId, document.getElementById('dateRange').value, document.getElementById('gameType').value);
                const totalGames = calculateTotalGames(playerId, document.getElementById('dateRange').value, document.getElementById('gameType').value);
                const winRate = totalGames > 0 ? (wins / totalGames) * 100 : 0;
                const avgPtsPerRound = calculateAveragePointsPerRound(playerId);
                const waddiesHoled = calculateWaddiesHoled(playerId);
                const scoringRounds = calculateScoringRounds(playerId);
                const bestRound = calculateBestRound(playerId);
                const hammerPct = calculateHammerPercentage(playerId);
                const firstPct = calculateShootingFirstPercentage(playerId);
                const carryPct = calculateCarryPercentage(playerId);
                
                // Update stats grid
                const statsGrid = document.getElementById('modalStats');
                statsGrid.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-value">${winRate.toFixed(1)}%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${avgPtsPerRound.toFixed(1)}</div>
                        <div class="stat-label">Avg Points/Round</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${waddiesHoled}</div>
                        <div class="stat-label">Waddies Holed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${bestRound} pts</div>
                        <div class="stat-label">Best Round</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${scoringRounds}</div>
                        <div class="stat-label">Scoring Rounds</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${hammerPct.toFixed(1)}%</div>
                        <div class="stat-label">With Hammer</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${firstPct.toFixed(1)}%</div>
                        <div class="stat-label">Shooting First</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${carryPct.toFixed(1)}%</div>
                        <div class="stat-label">Carry %</div>
                    </div>
                `;

                // Update chart
                updatePlayerChart(player);

                // Show match history
                updateMatchHistory(player);

                modal.style.display = 'block';
            }

            // Initialize event listeners
            document.querySelectorAll('.stats-table th').forEach(th => {
                th.onclick = () => {
                    const column = th.dataset.sort;
                    if (currentSort.column === column) {
                        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        currentSort.column = column;
                        currentSort.direction = 'desc';
                    }
                    updateTable();
                };
            });

            document.getElementById('dateRange').onchange = updateTable;
            document.getElementById('gameType').onchange = updateTable;
            document.getElementById('levelFilter').onchange = updateTable;

            // Load initial data
            loadPlayerStats();
        });

        // Calculation helper functions
        function getPlayerGames(playerId) {
            const allGames = window.gamesData || {};
            return Object.values(allGames).filter(game => {
                // Support both schema variants: nested teams or flat team1Players/team2Players arrays
                const team1Players = game.teams?.team1?.players ? Object.keys(game.teams.team1.players) : game.team1Players;
                const team2Players = game.teams?.team2?.players ? Object.keys(game.teams.team2.players) : game.team2Players;
                const playerInTeam1 = Array.isArray(team1Players) ? team1Players.includes(playerId) : !!team1Players?.[playerId];
                const playerInTeam2 = Array.isArray(team2Players) ? team2Players.includes(playerId) : !!team2Players?.[playerId];
                return playerInTeam1 || playerInTeam2;
            });
        }

        function getPlayerGameEntries(playerId) {
            const prRoot = (window.playerRoundsData && window.playerRoundsData[playerId]) || {};
            return Object.entries(prRoot).map(([gameId, node]) => {
                const roundsObj = node.rounds || {};
                const roundsArr = Array.isArray(roundsObj) ? roundsObj : Object.values(roundsObj);
                return { gameId, meta: node.meta || {}, rounds: roundsArr.filter(Boolean) };
            });
        }

        function entryPassesFilters(entry, dateRange, gameType, levelFilter) {
            if (!(entry.meta && entry.meta.isValid)) return false;
            if (gameType && gameType !== 'all' && entry.meta.gameType && entry.meta.gameType !== gameType) return false;
            const game = (window.gamesData && window.gamesData[entry.gameId]) || null;
            if (dateRange && dateRange !== 'all' && game && typeof game.date === 'number') {
                if (!filterByDateRange(game.date, dateRange)) return false;
            }
            // Level filter: treat Pro as scoringMode === 'teamAttempts' OR presence of per-round waddieCounts
            if (levelFilter && levelFilter !== 'all') {
                if (levelFilter === 'pro') {
                    const isProByMode = game && game.scoringMode === 'teamAttempts';
                    const hasCounts = entry.rounds && entry.rounds.some(r => r && r.waddieCounts && (typeof r.waddieCounts.holed === 'number'));
                    if (!isProByMode && !hasCounts) return false;
                }
            }
            return true;
        }

        function getGameById(gameId) {
            return window.gamesData ? window.gamesData[gameId] : null;
        }

        function getGameRoundsArray(game) {
            if (!game) return [];
            const rounds = game.rounds || [];
            return Array.isArray(rounds) ? rounds : Object.values(rounds);
        }

        function getPlayerTeamInfo(playerId, game) {
            if (!game || !game.teams) return { teamId: null, teamIndex: null };
            const team1Players = game.teams.team1 && game.teams.team1.players ? Object.keys(game.teams.team1.players) : [];
            const team2Players = game.teams.team2 && game.teams.team2.players ? Object.keys(game.teams.team2.players) : [];
            if (team1Players.includes(playerId)) {
                return { teamId: game.teams.team1.id, teamIndex: 1 };
            }
            if (team2Players.includes(playerId)) {
                return { teamId: game.teams.team2.id, teamIndex: 2 };
            }
            return { teamId: null, teamIndex: null };
        }

        function computeHammerSeries(game) {
            if (!game || !game.teams) return [];
            const rounds = getGameRoundsArray(game);
            const t1 = game.teams.team1?.id;
            const t2 = game.teams.team2?.id;
            if (!t1 || !t2 || rounds.length === 0) return [];

            function simulate(initialHammer) {
                let hammer = initialHammer;
                const perRound = [];
                for (const r of rounds) {
                    const pts = Number(r?.pointsScored || 0);
                    const scoringTeam = r?.scoringTeam || null;
                    if (pts === 0 && scoringTeam && scoringTeam !== hammer) {
                        return null; // invalid under assumptions
                    }
                    perRound.push(hammer);
                    if (pts > 0 && scoringTeam) {
                        hammer = scoringTeam; // scoring team gets next hammer
                    } else {
                        hammer = hammer === t1 ? t2 : t1; // wash flips hammer
                    }
                }
                return perRound;
            }

            return simulate(t1) || simulate(t2) || simulate(t1) || [];
        }

        function computeAttributionForEntry(playerId, entry) {
            const game = getGameById(entry.gameId);
            const rounds = entry.rounds || [];
            const gameRounds = getGameRoundsArray(game);
            const { teamId, teamIndex } = getPlayerTeamInfo(playerId, game);
            let pointsTotal = 0;
            let scoringRounds = 0;
            let tossedRounds = 0;

            rounds.forEach(r => {
                const rn = r.roundNumber || 0;
                const gr = gameRounds.find(grr => (grr?.roundNumber || 0) === rn) || gameRounds[rn - 1] || null;
                let iTossed = false;
                let teamScoredThisRound = false;
                let teamPoints = 0;

                if (gr) {
                    if (teamIndex === 1) iTossed = (gr.team1TosserId === playerId);
                    else if (teamIndex === 2) iTossed = (gr.team2TosserId === playerId);
                    teamScoredThisRound = (teamId && gr.scoringTeam === teamId) || false;
                    teamPoints = Number(gr.pointsScored || 0);
                }

                if (iTossed) tossedRounds++;

                const perPlayer = Number(r.score || 0);
                if (perPlayer > 0) {
                    pointsTotal += perPlayer;
                    scoringRounds += 1;
                } else if (iTossed && teamScoredThisRound && teamPoints > 0) {
                    // Fallback attribution to tosser when per-player score not recorded
                    pointsTotal += teamPoints;
                    scoringRounds += 1;
                }
            });

            const tossedInGame = tossedRounds > 0;
            return { pointsTotal, scoringRounds, tossedRounds, tossedInGame };
        }

        function getPlayerRounds(playerId, gameId) {
            const playerRoundsRoot = window.playerRoundsData || {};
            // player-rounds path is nested by playerId then gameId
            const playerNode = playerRoundsRoot[playerId] || {};
            const gameNode = playerNode[gameId] || {};
            // rounds may be an array-like object keyed by indices; convert to array, skip nulls/index 0
            const roundsObj = gameNode.rounds || {};
            const roundsArr = Array.isArray(roundsObj) ? roundsObj : Object.values(roundsObj);
            return roundsArr.filter(Boolean);
        }

        function calculateWins(playerId, dateRange, gameType, levelFilter) {
            return getPlayerGameEntries(playerId)
                .filter(e => entryPassesFilters(e, dateRange, gameType, levelFilter))
                .reduce((sum, e) => sum + (e.meta.isWin ? 1 : 0), 0);
        }

        function calculateLosses(playerId, dateRange, gameType, levelFilter) {
            return getPlayerGameEntries(playerId)
                .filter(e => entryPassesFilters(e, dateRange, gameType, levelFilter))
                .reduce((sum, e) => sum + (!e.meta.isWin ? 1 : 0), 0);
        }

        function calculateTotalGames(playerId, dateRange, gameType, levelFilter) {
            return getPlayerGameEntries(playerId).filter(e => entryPassesFilters(e, dateRange, gameType, levelFilter)).length;
        }

        function calculateWinPercent(playerId) {
            const wins = calculateWins(playerId);
            const totalGames = calculateTotalGames(playerId);
            return totalGames > 0 ? (wins / totalGames) * 100 : 0;
        }

        function calculateWaddiesHoled(playerId) {
            // Prefer per-round numeric counts when available (v2). Fallback to boolean snapshot (counts as 1 when holed true).
            return getPlayerGameEntries(playerId)
                .filter(e => e.meta && e.meta.isValid)
                .reduce((total, e) => total + e.rounds.reduce((sum, r) => {
                    if (!r) return sum;
                    if (r.waddieCounts && typeof r.waddieCounts.holed === 'number') return sum + r.waddieCounts.holed;
                    if (r.waddieStats && r.waddieStats.holed === true) return sum + 1;
                    return sum;
                }, 0), 0);
        }

        function calculateScoringRounds(playerId) {
            return getPlayerGameEntries(playerId)
                .filter(e => e.meta && e.meta.isValid)
                .reduce((total, e) => total + computeAttributionForEntry(playerId, e).scoringRounds, 0);
        }

        function calculateAveragePointsPerRound(playerId) {
            let totalPoints = 0;
            let totalRounds = 0;
            getPlayerGameEntries(playerId)
                .filter(e => e.meta && e.meta.isValid)
                .forEach(e => {
                    const attr = computeAttributionForEntry(playerId, e);
                    totalPoints += attr.pointsTotal;
                    totalRounds += attr.tossedRounds;
                });
            return totalRounds > 0 ? totalPoints / totalRounds : 0;
        }

        function calculatePointsScored(playerId, dateRange, gameType) {
            // Sum of per-round points using per-player score, with fallback attribution when needed
            return getPlayerGameEntries(playerId)
                .filter(e => entryPassesFilters(e, dateRange, gameType, document.getElementById('levelFilter').value))
                .reduce((sum, e) => sum + computeAttributionForEntry(playerId, e).pointsTotal, 0);
        }

        function calculateBestRound(playerId) {
            return getPlayerGameEntries(playerId)
                .filter(e => e.meta && e.meta.isValid)
                .reduce((best, e) => {
                    const pointsThisGame = computeAttributionForEntry(playerId, e);
                    // derive best attributed round from raw rounds + game linkage
                    const game = getGameById(e.gameId);
                    const gameRounds = getGameRoundsArray(game);
                    const { teamId, teamIndex } = getPlayerTeamInfo(playerId, game);
                    let bestRound = 0;
                    e.rounds.forEach(r => {
                        const rn = r.roundNumber || 0;
                        const gr = gameRounds.find(grr => (grr?.roundNumber || 0) === rn) || gameRounds[rn - 1] || null;
                        const per = Number(r.score || 0);
                        if (per > 0) bestRound = Math.max(bestRound, per);
                        else if (gr && teamId && ((teamIndex === 1 && gr.team1TosserId === playerId) || (teamIndex === 2 && gr.team2TosserId === playerId)) && gr.scoringTeam === teamId) {
                            bestRound = Math.max(bestRound, Number(gr.pointsScored || 0));
                        }
                    });
                    return Math.max(best, bestRound);
                }, 0);
        }

        function calculateHammerPercentage(playerId) {
            // Player-level: among rounds the player tossed, % where player tossed with hammer and scored (attributed)
            let denom = 0;
            let numer = 0;
            const entries = getPlayerGameEntries(playerId).filter(e => e.meta && e.meta.isValid);
            for (const e of entries) {
                const game = getGameById(e.gameId);
                const gameRounds = getGameRoundsArray(game);
                const hammerByRound = computeHammerSeries(game);
                const { teamId, teamIndex } = getPlayerTeamInfo(playerId, game);
                if (!teamId || hammerByRound.length === 0) continue;
                for (const r of e.rounds) {
                    const rn = r.roundNumber || 0;
                    const gr = gameRounds.find(grr => (grr?.roundNumber || 0) === rn) || gameRounds[rn - 1] || null;
                    if (!gr) continue;
                    const iTossed = (teamIndex === 1) ? (gr.team1TosserId === playerId) : (gr.team2TosserId === playerId);
                    if (!iTossed) continue;
                    const hadHammer = (hammerByRound[rn - 1] === teamId);
                    if (!hadHammer) continue;
                    denom += 1;
                    const per = Number(r.score || 0);
                    const teamScored = Number(gr.pointsScored || 0) > 0 && gr.scoringTeam === teamId;
                    const attributed = per > 0 ? per : (iTossed && teamScored ? Number(gr.pointsScored || 0) : 0);
                    if (attributed > 0) numer += 1;
                }
            }
            return denom > 0 ? (numer / denom) * 100 : 0;
        }

        function calculateShootingFirstPercentage(playerId) {
            // Player-level: among rounds the player tossed, % where player tossed first (no hammer) and scored (attributed)
            let denom = 0;
            let numer = 0;
            const entries = getPlayerGameEntries(playerId).filter(e => e.meta && e.meta.isValid);
            for (const e of entries) {
                const game = getGameById(e.gameId);
                const gameRounds = getGameRoundsArray(game);
                const hammerByRound = computeHammerSeries(game);
                const { teamId, teamIndex } = getPlayerTeamInfo(playerId, game);
                if (!teamId || hammerByRound.length === 0) continue;
                for (const r of e.rounds) {
                    const rn = r.roundNumber || 0;
                    const gr = gameRounds.find(grr => (grr?.roundNumber || 0) === rn) || gameRounds[rn - 1] || null;
                    if (!gr) continue;
                    const iTossed = (teamIndex === 1) ? (gr.team1TosserId === playerId) : (gr.team2TosserId === playerId);
                    if (!iTossed) continue;
                    const shootsFirst = (hammerByRound[rn - 1] !== teamId);
                    if (!shootsFirst) continue;
                    denom += 1;
                    const per = Number(r.score || 0);
                    const teamScored = Number(gr.pointsScored || 0) > 0 && gr.scoringTeam === teamId;
                    const attributed = per > 0 ? per : (iTossed && teamScored ? Number(gr.pointsScored || 0) : 0);
                    if (attributed > 0) numer += 1;
                }
            }
            return denom > 0 ? (numer / denom) * 100 : 0;
        }

        function calculateCarryPercentage(playerId) {
            // Average of per-game shares: myAttributedPointsThisGame / teamScore
            const shares = getPlayerGameEntries(playerId)
                .filter(e => e.meta && e.meta.isValid && (e.meta.teamScore || 0) > 0)
                .map(e => {
                    const myPts = computeAttributionForEntry(playerId, e).pointsTotal;
                    return myPts / e.meta.teamScore;
                });
            if (shares.length === 0) return 0;
            const avg = shares.reduce((a, b) => a + b, 0) / shares.length;
            return avg * 100;
        }

        function filterByDateRange(gameDate, range) {
            if (!range || range === 'all') return true;
            const date = new Date(gameDate * 1000);
            const now = new Date();
            switch (range) {
                case 'month':
                    return date >= new Date(now.setMonth(now.getMonth() - 1));
                case '3months':
                    return date >= new Date(now.setMonth(now.getMonth() - 3));
                case 'year':
                    return date >= new Date(now.setFullYear(now.getFullYear() - 1));
                default:
                    return true;
            }
        }

        function filterByGameType(gameType, filter) {
            if (!filter || filter === 'all') return true;
            return gameType === filter;
        }

        function updatePlayerChart(player) {
            const ctx = document.getElementById('playerChart');
            if (window.playerChartInstance && typeof window.playerChartInstance.destroy === 'function') {
                window.playerChartInstance.destroy();
            }

            window.playerChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Game 1', 'Game 2', 'Game 3', 'Game 4', 'Game 5'], // Replace with actual game dates
                    datasets: [{
                        label: 'Points per Game',
                        data: [15, 18, 21, 17, 19], // Replace with actual point data
                        borderColor: '#0070c9',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Recent Performance'
                        }
                    }
                }
            });
        }

        function updateMatchHistory(player) {
            const matchesList = document.getElementById('playerMatches');
            matchesList.innerHTML = '<h3>Recent Matches</h3>';
            
            // Add match history items (implement based on your data structure)
            matchesList.innerHTML += `
                <div class="match-item">
                    <div>vs. Opponent Name</div>
                    <div>Score: 21-15</div>
                    <div>Date: March 1, 2024</div>
                </div>
            `;
        }
    </script>
</body>
</html>
